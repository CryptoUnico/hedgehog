{"version":3,"sources":["../../opyn-connector/index.js","../../opyn-connector/main/connector.js","../../opyn-connector/utils/utils.js","utils/opynUtils.js","utils/getChartData.js","components/Form.js","components/App.js","serviceWorker.js","index.js"],"names":["router","require","module","exports","batchRequest","FACTORY_ABI","EXCHANGE_ABI","OTOKEN_ABI","convertToFloatingPoint","OpynConnector","web3","config","Error","this","option","expiry","Math","floor","Date","now","filters","getDefaultFilters","getOptionsContractAddresses","getOptionsInformation","optionsAddresses","optionsInfo","optionsContracts","filterOptionsContracts","Promise","resolve","reject","eth","Contract","factory","methods","getNumberOfOptionsContracts","call","then","numberOfOptions","calls","Array","parseInt","keys","map","optionKey","ethCall","makeBatchRequest","result","catch","err","pools","constants","floatingPointFields","addressFields","address","methodName","onError","console","log","flat","optionList","optionIndex","length","currentOption","toLowerCase","propertyIndex","currentProperty","currentPropertyValue","includes","push","contracts","filtered","filterIndex","currentFilter","filter","oTokenAddress","paymentTokenAddress","oTokensToBuy","exchange","premiumToPay","isCall","amountOptionsToBuy","oTokensNeeded","round","strikePrice","pow","decimals","scientificNumber","value","exponent","ethAndWeth","generateOptionKey","strike","underlying","getOptionsForPair","optionsList","merge","getCallStrikePrice","getPutStrikePrice","put","points","calculateImpermanentLoss","priceFactor","abs","sqrt","addOptionStrikePriceToPoints","pointsOfInterest","currentPrice","x","absolutePrices","point","absolutePrice","indexToInsertAt","findIndex","number","splice","impermanentLoss","identifier","calculateOptionReturn","forEach","callReturn","putReturn","getPricePoints","maxFactor","price","callPrice","putPrice","relevantPoints","addAbsolutePrice","reverse","calculateOptionReturns","getChartAndPurchaseData","callOption","putOption","onPriceUpdate","opynConnector","callStrikePrice","undefined","putStrikePrice","putsNeeded","callsNeeded","chartData","chart","type","title","text","series","name","data","xAxis","categories","toPrecision","toString","priceChangePercentage","toFixed","getPriceChangeLabelForAxis","yAxis","timestamp","all","getPriceOrResolveToZero","getPriceOfPurchase","getOptionsPricesAsync","callCost","putCost","optionsRequired","Form","state","currentPair","supportedPairs","optionsExpiry","Object","props","optionsData","token0","token1","callIndex","putIndex","pairIndex","recalculateChartData","fetchUniswapPoolPrice","prevProps","prevState","prevPropsNoConnector","propsNoConnector","JSON","stringify","token","Token","ChainId","MAINNET","Fetcher","fetchPairData","WETH","chainId","pair","route","Route","parseFloat","midPrice","setState","event","target","isPut","attributeName","updateChartData","getPutOptions","getCallOptions","updatePriceData","callOptions","putOptions","className","htmlFor","id","index","token0_name","token1_name","onClick","setPriceFactor","onChange","evt","setOptionsExpiry","key","dateFormat","setOptionIndex","disabled","Component","App","ethereum","priceData","calculateOptionCost","cost","amountOfOptions","chartDataToDisplay","calculateOptionsCost","infuraweb3","Web3","providers","HttpProvider","optionRequestState","init","restructured","getRestructuredOptions","highcharts","Highcharts","options","getErrorMessage","href","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.9101a61b.chunk.js","sourcesContent":["const router = require(\"./main/connector\");\n\nmodule.exports = router;","const batchRequest = require('web3-batch-request');\n\nconst FACTORY_ABI = require('../abi/factory.json');\nconst EXCHANGE_ABI = require('../abi/exchange.json');\nconst OTOKEN_ABI = require('../abi/otoken.json');\nconst { convertToFloatingPoint } = require('../utils/utils');\n\nclass OpynConnector {\n    constructor({\n        web3,\n        config\n    }) {\n        if (!web3) {\n            throw new Error(\"You must pass in a web3 instance\");\n        }\n\n        if (!config) {\n            this.config = require('../constants/mainnet.json');\n        } else {\n            this.config = config;\n        }\n\n        this.web3 = web3;\n    }\n\n    getDefaultFilters() {\n        const filterExpired = option => option.expiry > Math.floor(Date.now() / 1000);\n        return [filterExpired];\n    }\n\n    /**\n     * Fetch all options from the factory and filter using the filters passed (if any - by default filters expired out)\n     *\n     * @param filters array of filters to run options through. by default filters any expired options.\n     * @returns array of options, filtered if any specified.\n     */\n    async init({ filters } = { filters: this.getDefaultFilters() }) {\n        await this.getOptionsContractAddresses();\n        let optionsInfo = await this.getOptionsInformation(this.optionsAddresses);\n        this.optionsContracts = this.filterOptionsContracts(optionsInfo, filters);\n        return this.optionsContracts;\n    }\n\n    getOptionsContractAddresses() {\n        return new Promise((resolve, reject) => {\n            new this.web3.eth.Contract(FACTORY_ABI, this.config.factory).methods.getNumberOfOptionsContracts().call().then(\n                numberOfOptions => {\n                    let calls = [...Array(parseInt(numberOfOptions)).keys()].map(optionKey => ({\n                        ethCall: new this.web3.eth.Contract(FACTORY_ABI, this.config.factory).methods.optionsContracts(optionKey).call\n                    }));\n\n                    batchRequest.makeBatchRequest(this.web3, calls).then(\n                        result => {\n                            this.optionsAddresses = result;\n                            resolve(result);\n                        }\n                    ).catch(err => {\n                        reject(\"Failed during fetch of pool addresses \" + err);\n                    });\n                }\n            ).catch(\n                err => reject(\"Failed to fetch option contracts count \" + err)\n            )\n        });\n    }\n\n    getOptionsInformation(pools, { filters } = { filters: []}) {\n        return new Promise((resolve, reject) => {\n\n            let constants = [\n                \"name\", \"isExerciseWindow\", \"totalSupply\", \"decimals\", \"liquidationFactor\", \"optionsExchange\",\n                \"underlying\", \"COMPOUND_ORACLE\", \"liquidationIncentive\", \"owner\", \"isOwner\", \"hasExpired\",\n                \"symbol\", \"transactionFee\", \"strike\", \"underlyingExp\", \"collateralExp\", \"oTokenExchangeRate\",\n                \"minCollateralizationRatio\", \"strikePrice\", \"collateral\", \"expiry\"\n            ];\n\n            //fields in this list will be converted to floating points when returned\n            let floatingPointFields = [\"liquidationFactor\", \"liquidationIncentive\", \"transactionFee\",\n                                       \"oTokenExchangeRate\", \"minCollateralizationRatio\", \"strikePrice\"];\n\n            //fields in this list will be lowercased to prevent any case-sensitivity issues when searching\n            let addressFields = [\"optionsExchange\", \"underlying\", \"COMPOUND_ORACLE\", \"owner\", \"strike\", \"collateral\"];\n\n            let calls = pools.map(address =>\n                    constants.map(methodName => ({\n                        ethCall: new this.web3.eth.Contract(OTOKEN_ABI, address).methods[methodName]().call,\n                        onError: err => console.log(\"Error on: \" + address + \" \" + methodName)\n                    })\n                )\n            ).flat();\n\n            batchRequest.makeBatchRequest(this.web3, calls).then(\n                result => {\n                    let optionList = [];\n\n                    //theres probably a more elegant way to do this with destructuring...\n                    for(let optionIndex = 0; optionIndex < pools.length; optionIndex++) {\n                        let currentOption = {};\n                        currentOption.address = pools[optionIndex].toLowerCase();\n                        for(let propertyIndex = 0; propertyIndex < constants.length; propertyIndex++) {\n                            let currentProperty = constants[propertyIndex];\n                            let currentPropertyValue = result[(optionIndex * constants.length) + propertyIndex];\n\n                            if(floatingPointFields.includes(currentProperty)) {\n                                currentOption[currentProperty] = convertToFloatingPoint(currentPropertyValue);\n                            } else if(addressFields.includes(currentProperty)) {\n                                currentOption[currentProperty] = currentPropertyValue.toLowerCase();\n                            } else {\n                                currentOption[currentProperty] = currentPropertyValue;\n                            }\n                        }\n\n                        optionList.push(currentOption);\n                    }\n\n                    this.optionsContracts = optionList;\n                    resolve(optionList);\n                }\n            ).catch(err => {\n                reject(err);\n            });\n        });\n    }\n\n    filterOptionsContracts(contracts, filters = []) {\n        let filtered = contracts;\n\n        if(filters.length > 0) {\n            for(let filterIndex = 0; filterIndex < filters.length; filterIndex++) {\n                const currentFilter = filters[filterIndex];\n                filtered = contracts.filter(option => currentFilter(option));\n            }\n        }\n\n        return filtered;\n    }\n\n    premiumToPay(oTokenAddress, paymentTokenAddress, oTokensToBuy) {\n        return new this.web3.eth.Contract(EXCHANGE_ABI, this.config.exchange).methods.premiumToPay(oTokenAddress, paymentTokenAddress, oTokensToBuy).call();\n    }\n\n    getPriceOfPurchase(option, isCall, amountOptionsToBuy, paymentTokenAddress = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\") {\n        let oTokensNeeded;\n\n        if(isCall) {\n            //todo: shouldnt need rounding - floating point precision issue. fix this!!!\n            oTokensNeeded = Math.round(amountOptionsToBuy / option.strikePrice);\n        } else {\n            //todo: shouldnt need rounding - floating point precision issue. fix this!!!\n            oTokensNeeded = Math.round(amountOptionsToBuy * Math.pow(10, option.decimals));\n        }\n\n        return this.premiumToPay(option.address, paymentTokenAddress, oTokensNeeded);\n    }\n}\n\nmodule.exports = OpynConnector;","module.exports = {\n    /**\n     * Converts a scientific number format to a floating point\n     * floating point number = value * 10 ** exponent\n     *\n     * @param scientificNumber { value, exponent } to fit equation above\n     */\n    convertToFloatingPoint: (scientificNumber) => {\n        return scientificNumber.value * Math.pow(10, scientificNumber.exponent)\n    }\n}","import merge from 'deepmerge';\n\nconst ethAndWeth = [\"0x0000000000000000000000000000000000000000\", \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"];\n\nconst generateOptionKey = (strike, underlying) => {\n    strike = strike.toLowerCase();\n    underlying = underlying.toLowerCase();\n\n    if(strike === ethAndWeth[1]) {\n        strike = ethAndWeth[0];\n    }\n\n    if(underlying === ethAndWeth[1]) {\n        underlying = ethAndWeth[1];\n    }\n\n    return strike > underlying ? strike + underlying : underlying + strike;\n}\n\nconst getRestructuredOptions = (data) => {\n    let restructured = {};\n\n    data.forEach(\n        option => {\n            const {strike, underlying, expiry} = option;\n            const optionKey = generateOptionKey(strike, underlying);\n\n            if (restructured[optionKey] === undefined) {\n                restructured[optionKey] = {};\n            }\n\n            if (restructured[optionKey][expiry] === undefined) {\n                restructured[optionKey][expiry] = [];\n            }\n\n            restructured[optionKey][expiry].push(option);\n        }\n    );\n\n    return restructured;\n}\n\nconst getOptionsForPair = (optionsList, strike, underlying) => {\n    strike = strike.toLowerCase();\n    underlying = underlying.toLowerCase();\n\n    //since for eth pairs we also need to check for weth, we form a list of keys we need and merge them after\n    const keys = [];\n\n    if(ethAndWeth.includes(strike)) {\n        keys.push(generateOptionKey(underlying, ethAndWeth[0]));\n        keys.push(generateOptionKey(underlying, ethAndWeth[1]));\n    } else if(ethAndWeth.includes(underlying)) {\n        keys.push(generateOptionKey(strike, ethAndWeth[0]));\n        keys.push(generateOptionKey(strike, ethAndWeth[1]));\n    } else {\n        keys.push(generateOptionKey(strike, underlying));\n    }\n\n    //return merged if 2 values, else merge with empty i.e. return first\n    return merge(optionsList[keys[0]], (optionsList[keys[1]] || {}));\n}\n\nconst getCallStrikePrice = call => {\n    const strikePrice = 1 / (call.strikePrice * Math.pow(10, call.decimals));\n    //todo math.round is a hack due to floating point precision... fix\n    return Math.round(strikePrice);\n}\n\nconst getPutStrikePrice = put => {\n    const strikePrice = put.strikePrice * Math.pow(10, put.decimals);\n    //todo math.round is a hack due to floating point precision... fix\n    return Math.round(strikePrice);\n}\n\nexport {\n    generateOptionKey,\n    getOptionsForPair,\n    getRestructuredOptions,\n    getCallStrikePrice,\n    getPutStrikePrice\n}","import { getCallStrikePrice, getPutStrikePrice } from './opynUtils';\n\n//these reflect a factor of the price e.g. 2 means 2x or 0.5x\nconst points = [1.25, 1.5, 1.75, 2, 3, 4, 5];\n\nconst calculateImpermanentLoss = priceFactor => Math.abs(2 * (Math.sqrt(priceFactor) / (priceFactor + 1)) - 1);\n\nconst addOptionStrikePriceToPoints = (pointsOfInterest, isCall, currentPrice, strikePrice) => {\n    const absolutePrices = pointsOfInterest.map(point => point.absolutePrice);\n\n    const isLargerThan = (x) => (number) => number > x;\n\n    //we need to put in the put price and call price into the price points at the right index\n    if (!absolutePrices.includes(strikePrice)) {\n        const indexToInsertAt = absolutePrices.findIndex(isLargerThan(strikePrice));\n        const priceFactor = strikePrice / currentPrice;\n        pointsOfInterest.splice(indexToInsertAt, 0, {\n            priceFactor,\n            absolutePrice: strikePrice,\n            impermanentLoss: calculateImpermanentLoss(priceFactor),\n            identifier: isCall ? 'callStrike' : 'putStrike'\n        });\n    }\n}\n\nconst calculateOptionReturn = (pointsOfInterest, isCall) => {\n    const identifier = isCall ? 'callStrike' : 'putStrike';\n    const strikePrice = pointsOfInterest.filter(point => point.identifier === identifier).map(point => point.absolutePrice);\n\n    //if a strike for the option exists calculate the returns for that option\n    if(strikePrice.length > 0) {\n        //populate all points with options return values\n        pointsOfInterest.forEach(\n            point => {\n                if(isCall) {\n                    point.callReturn = point.absolutePrice <= strikePrice[0] ? 0 : point.absolutePrice - strikePrice[0];\n                } else {\n                    point.putReturn = point.absolutePrice >= strikePrice[0] ? 0 : strikePrice[0] - point.absolutePrice;\n                }\n            }\n        )\n    }\n}\n\nconst calculateOptionReturns = (pointsOfInterest) => {\n    calculateOptionReturn(pointsOfInterest, true);\n    calculateOptionReturn(pointsOfInterest, false);\n}\n\n/**\n * This gets the points on the x-axis which we want to plot. It uses the \"points\" array to find price\n * points in the range we care about\n *\n * @param maxFactor max price factor we care about e.g. 2 means 0.5x - , 3 means 0.33x - 3x etc\n * @param price current price of asset\n * @param callPrice strike price of call - this point is plotted\n * @param putPrice strike price of put - this point is plotted\n * @returns a list of price points, with each having a price, price factor (ratio to current price) and impermanentloss\n */\nconst getPricePoints = (maxFactor, price, callPrice, putPrice) => {\n    const relevantPoints = points.filter(value => value <= maxFactor).map(value => ({\n        priceFactor: value,\n        impermanentLoss: calculateImpermanentLoss(value)\n    }));\n\n    const inversePoints = [...relevantPoints].reverse().map(\n        value => ({\n            ...value,\n            priceFactor: 1 / value.priceFactor\n        })\n    )\n\n    const addAbsolutePrice = pointsOfInterest => pointsOfInterest.map(point => ({\n            ...point,\n            absolutePrice: point.priceFactor * price\n        })\n    );\n\n    let pointsOfInterest = [\n        addAbsolutePrice(inversePoints),\n        { priceFactor: 1, impermanentLoss: 0, absolutePrice: price },\n        addAbsolutePrice(relevantPoints)\n    ].flat();\n\n    if (callPrice) {\n        addOptionStrikePriceToPoints(pointsOfInterest, true, price, callPrice);\n    }\n\n    if (putPrice) {\n        addOptionStrikePriceToPoints(pointsOfInterest, false, price, putPrice);\n    }\n\n    //we avoid doing this until all points are generated otherwise we will have missing data for some points\n    calculateOptionReturns(pointsOfInterest);\n\n    return pointsOfInterest;\n};\n\nconst getPriceChangeLabelForAxis = (currentPrice, point) => {\n    const priceChangePercentage = ((point.priceFactor - 1) * 100);\n    if(priceChangePercentage === 0) {\n        return '';\n    } else if(priceChangePercentage > 0) {\n        return '<br />(+' + priceChangePercentage.toFixed(1).toString() + '%)';\n    } else {\n        return '<br />(' + priceChangePercentage.toFixed(1).toString()  + '%)';\n    }\n}\n\n/**\n * Generates the chart data from the relevant inputs\n *\n * @param priceFactor the factor of change in price we care about. e.g. 2 means 0.5x - 2x\n * @param currentPrice the current price of the pair\n * @param callStrikePrice the strike price of the call we are hedging with (-1 if no call used)\n * @param putStrikePrice the strike price of the put we are hedging with (-1 if no put used)\n * @param callCost the cost of a single call option\n * @param putCost the cost of a single put option\n * @param opynConnector an instance of OpynConnector so we can fetch prices of options\n */\nconst getChartAndPurchaseData = ({\n      priceFactor,\n      currentPrice,\n      callOption,\n      putOption,\n      onPriceUpdate,\n      opynConnector\n}) => {\n    const callStrikePrice = !callOption ? undefined : getCallStrikePrice(callOption);\n    const putStrikePrice = !putOption ? undefined : getPutStrikePrice(putOption);\n\n    const pointsOfInterest = getPricePoints(priceFactor, currentPrice, callStrikePrice, putStrikePrice);\n\n    let putsNeeded = 0;\n    if(pointsOfInterest[0].putReturn > 0) {\n        putsNeeded = pointsOfInterest[0].impermanentLoss * currentPrice / pointsOfInterest[0].putReturn;\n    }\n\n    let callsNeeded = 0;\n    if(pointsOfInterest[pointsOfInterest.length - 1].callReturn > 0) {\n        callsNeeded = pointsOfInterest[pointsOfInterest.length - 1].impermanentLoss * currentPrice / pointsOfInterest[pointsOfInterest.length - 1].callReturn;\n    }\n\n    const chartData = {\n        chart: {\n            type: 'spline'\n        },\n        title: {\n            text: 'Profit/Loss'\n        },\n        series: [\n            {\n                name: 'Impermanent Loss',\n                data: pointsOfInterest.map(point => point.impermanentLoss * currentPrice)\n            },\n            /*\n            {\n                name: 'Net Profit',\n                data: calculatePutReturns().map((val, id) => val + calculateCallReturns()[id] + costOfOptions - (absoluteImpermanentLoss[id] || 0))\n            }\n            */\n        ],\n        xAxis: {\n            categories: pointsOfInterest.map(point => {\n                return point.absolutePrice.toPrecision(5).toString() + getPriceChangeLabelForAxis(currentPrice, point)\n            }),\n            title: {\n                text: \"Price (USDC)\"\n            }\n        },\n        yAxis: {\n            title: {\n                text: \"Profit/Loss (USDC)\"\n            }\n        },\n    };\n\n    const timestamp = Date.now();\n\n    //if undefined, resolve promise to 0 else get price\n    const getOptionsPricesAsync = () => {\n        const getPriceOrResolveToZero = (option, isCall, amountOptionsToBuy) => {\n            if(option) {\n                return opynConnector.getPriceOfPurchase(option, isCall, amountOptionsToBuy);\n            }\n            return new Promise((resolve) => {\n                resolve(0)\n            });\n        }\n\n        return [\n            getPriceOrResolveToZero(callOption, true, 1),\n            getPriceOrResolveToZero(putOption, false, 1)\n        ];\n    }\n\n    //publish result to state async\n    Promise.all(getOptionsPricesAsync()).then(\n        ([callCost, putCost]) => {\n            const priceData = {\n                timestamp,\n                callCost,\n                putCost,\n                callsNeeded,\n                putsNeeded,\n            }\n            onPriceUpdate(timestamp, priceData)\n        }\n    )\n\n    if(putStrikePrice) {\n        chartData.series.push({\n            name: 'Put Returns',\n            data: pointsOfInterest.map(point => putsNeeded * point.putReturn)\n        });\n    }\n\n    if(callStrikePrice) {\n        chartData.series.push({\n            name: 'Call Returns',\n            data: pointsOfInterest.map(point => callsNeeded * point.callReturn)\n        });\n    }\n\n    return {\n        chartData,\n        optionsRequired: {\n            callsNeeded,\n            putsNeeded\n        }\n    };\n}\n\nexport default getChartAndPurchaseData;","import React, {Component} from 'react';\nimport { ChainId, Token, WETH, Fetcher, Route } from '@uniswap/sdk';\nimport dateFormat from 'dateformat';\nimport getChartAndPurchaseData from '../utils/getChartData'; //hardcoded for now...\nimport {\n    getOptionsForPair,\n    generateOptionKey,\n    getCallStrikePrice,\n    getPutStrikePrice\n} from '../utils/opynUtils';\nimport supportedPairs from './../constants/supportedPairs.json';\n\nclass Form extends Component {\n    state = {\n        currentPair: supportedPairs[0],\n        priceFactor: 2,\n        optionsExpiry: Object.keys(this.props.optionsData[generateOptionKey(supportedPairs[0].token0,supportedPairs[0].token1)])[0],\n        callIndex: 0,\n        putIndex: 0,\n        callsNeeded: 0,\n        putsNeeded: 0,\n        currentPrice: 1,\n        pairIndex: 0\n    }\n\n    componentDidMount() {\n        this.recalculateChartData();\n\n        //todo: this should update periodically to keep price fresh\n        this.fetchUniswapPoolPrice();\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        const { opynConnector: a, ...prevPropsNoConnector } = prevProps;\n        const { opynConnector: b, ...propsNoConnector } = this.props;\n\n        if(JSON.stringify(prevPropsNoConnector) !== JSON.stringify(propsNoConnector) || JSON.stringify(prevState) !== JSON.stringify(this.state)) {\n            this.recalculateChartData();\n        }\n    }\n\n    fetchUniswapPoolPrice() {\n        const token = new Token(ChainId.MAINNET, supportedPairs[this.state.pairIndex].token1, 6);\n\n        Fetcher.fetchPairData(token, WETH[token.chainId]).then(\n            pair => {\n                const route = new Route([pair], WETH[token.chainId])\n                const currentPrice = parseFloat(route.midPrice.toFixed(2).toString());\n                this.setState({ currentPrice });\n            }\n        )\n    }\n\n    setPriceFactor(priceFactor) {\n        this.setState({\n            priceFactor\n        });\n    };\n\n    setOptionsExpiry(event) {\n        const optionsExpiry = event.target.value;\n        this.setState({\n            optionsExpiry,\n            putIndex: 0,\n            callIndex: 0\n        });\n    }\n\n    /**\n     * Set index of put or call\n     * @param isPut true to set put index, false for call index\n     */\n    setOptionIndex(event, isPut) {\n        const attributeName = isPut ? \"putIndex\" : \"callIndex\";\n        this.setState({\n            [attributeName]: parseInt(event.target.value),\n        });\n    }\n\n    recalculateChartData() {\n        //settings\n        const { priceFactor, optionsExpiry, putIndex, callIndex, currentPrice } = this.state;\n        const { optionsData, updateChartData, opynConnector } = this.props;\n\n        const putOption = this.getPutOptions()[putIndex];\n        const callOption = this.getCallOptions()[callIndex];\n\n        const {\n            chartData,\n            optionsRequired: {\n                callsNeeded,\n                putsNeeded\n            }\n        } = getChartAndPurchaseData({\n            priceFactor,\n            currentPrice,\n            callOption,\n            putOption,\n            onPriceUpdate: this.props.updatePriceData,\n            opynConnector\n        });\n\n        this.setState({\n            callsNeeded,\n            putsNeeded\n        });\n\n        updateChartData(chartData);\n    }\n\n    getCallOptions() {\n        const { currentPair, optionsExpiry } = this.state;\n        const { optionsData } = this.props;\n        const callOptions = getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)[optionsExpiry];\n        if(callOptions) {\n            return callOptions.filter(option => option.underlying === '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\n        }\n        return [];\n    }\n\n    getPutOptions() {\n        const { currentPair, optionsExpiry } = this.state;\n        const { optionsData } = this.props;\n        const putOptions = getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)[optionsExpiry];\n        if(putOptions) {\n            return putOptions.filter(option => option.underlying !== '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\n        }\n        return [];\n    }\n\n    render() {\n        const { optionsData } = this.props;\n        const { priceFactor, optionsExpiry, callsNeeded, putsNeeded, currentPair } = this.state;\n\n        return (\n            <div className=\"options-form\">\n                <div className=\"label-holder\">\n                    <label htmlFor=\"pool\">Pick a pool:</label>\n                </div>\n\n                <select name=\"pool\" id=\"pool\" className=\"form-control\">\n                    {supportedPairs.map(\n                        (pair, index) => (\n                            <option value={index}>{pair.token0_name + \"-\" + pair.token1_name}</option>\n                        )\n                    )}\n                </select>\n\n                <br/>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"priceFactor\">Price Change to Hedge:</label>\n                </div>\n\n                <div className=\"button-group\">\n                    <button className={priceFactor === 2 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(2)}>2x\n                    </button>\n                    <button className={priceFactor === 3 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(3)}>3x\n                    </button>\n                    <button className={priceFactor === 4 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(4)}>4x\n                    </button>\n                    <button className={priceFactor === 5 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(5)}>5x\n                    </button>\n                </div>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"expiry\">Options Expiry Date:</label>\n                </div>\n\n                <select name=\"expiry\" id=\"expiry\" className=\"form-control\" value={optionsExpiry}\n                        onChange={(evt) => this.setOptionsExpiry(evt)}>\n                    {\n                        Object.keys(getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)).map(\n                            key => (\n                                <option value={key}>{dateFormat(new Date(key * 1000), \"d mmmm yyyy h:MM\")}</option>\n                            )\n                        )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"call\">Call Strike Price:</label>\n                </div>\n\n                <select name=\"call\" id=\"call\" className=\"form-control\" onChange={(evt) => this.setOptionIndex(evt, false)}>\n                    {\n                        this.getCallOptions().length < 1 ?\n                            <option value=\"-1\" disabled=\"disabled\">No calls available</option>\n                        :\n                        this.getCallOptions().map(\n                            (call, index) => <option value={index}>{getCallStrikePrice(call)}</option>\n                        )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"put\">Put Strike Price:</label>\n                </div>\n\n                <select name=\"put\" id=\"put\" className=\"form-control\" onChange={(evt) => this.setOptionIndex(evt, true)}>\n                    {\n                        this.getPutOptions().length < 1 ?\n                            <option value=\"-1\" disabled=\"disabled\">No puts available</option>\n                            :\n                            this.getPutOptions().map(\n                                (put, index) => <option value={index}>{getPutStrikePrice(put)}</option>\n                            )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"call-tokens-amount\">Call options to Buy:</label>\n                </div>\n\n                <input className=\"form-control\" name=\"call-tokens-amount\" value={callsNeeded} disabled/>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"put-tokens-amount\">Put options to Buy:</label>\n                </div>\n\n                <input className=\"form-control\" name=\"put-tokens-amount\" value={putsNeeded} disabled/>\n            </div>\n        )\n    }\n}\n\nexport default Form;","import React, { Component, Fragment } from 'react';\nimport Form from './Form';\nimport Highcharts from 'highcharts';\nimport HighchartsReact from \"highcharts-react-official\";\nimport Web3 from \"web3\";\nimport OpynConnector from 'opyn-connector';\nimport { getRestructuredOptions } from '../utils/opynUtils';\n\nclass App extends Component {\n    state = {\n        chartData: {},\n        ethereum: {},\n        optionsData: {},\n        priceData: {\n            timestamp: 0,\n            callCost: 0,\n            putCost: 0,\n            callsNeeded: 0,\n            putsNeeded: 0,\n        }\n    }\n\n    calculateOptionsCost() {\n        const { callCost, putCost, callsNeeded, putsNeeded } = this.state.priceData;\n\n        const calculateOptionCost = (cost, amountOfOptions) => {\n            if(!cost || !amountOfOptions) {\n                return 0;\n            }\n            return (cost / 1000000) * amountOfOptions;\n        }\n\n        return calculateOptionCost(callCost, callsNeeded) + calculateOptionCost(putCost, putsNeeded);\n    }\n\n    chartDataToDisplay() {\n        if(Object.keys(this.state.chartData).length > 0) {\n            let chartDataToDisplay = {...this.state.chartData};\n            chartDataToDisplay.series = [...chartDataToDisplay.series]\n            chartDataToDisplay.series.push({\n                name: 'Options Cost',\n                data: chartDataToDisplay.series[0].data.map(point => this.calculateOptionsCost())\n            });\n            return chartDataToDisplay;\n        }\n        return {};\n    }\n\n    componentDidMount() {\n        //for some reason metamask doesnt like batch requests... using infura\n        const infuraweb3 = new Web3(\n            new Web3.providers.HttpProvider(`https://mainnet.infura.io/v3/3425960a247b4ae9b94e7d0e51c1bef0`)\n        );\n        const opynConnector = new OpynConnector({ web3: infuraweb3 });\n        this.setState({\n            ethereum: {\n                web3: infuraweb3,\n            },\n            chartData: {},\n            opynConnector,\n        });\n        this.setState({ optionRequestState: \"LOADING\" })\n        opynConnector.init().then(\n            result => {\n                const optionsData = getRestructuredOptions(result);\n                this.setState({\n                    optionRequestState: \"SUCCESS\",\n                    optionsData\n                })\n            }\n        ).catch(\n            err => this.setState({ optionRequestState: \"FAILED\" })\n        );\n    }\n\n    //take timestamp in case we get requests back out of order\n    updatePriceData(timestamp, priceData) {\n        if(timestamp > this.state.priceData.timestamp) {\n            this.setState({\n                priceData\n            });\n        }\n    }\n\n    updateChartData(chartData) {\n        this.setState({ chartData })\n    }\n\n    getErrorMessage() {\n        if(!this.state.ethereum.web3) {\n            return \"Failed to get web3 provider\";\n        } else if(this.state.optionRequestState === \"LOADING\") {\n            return \"Loading options... this may take up to 30 seconds\"\n        } else if(this.state.optionRequestState === \"FAILED\") {\n            return \"Failed to fetch option data. Refresh to try again\"\n        }\n    }\n\n    render() {\n        const { optionsData, ethereum, optionRequestState, opynConnector } = this.state;\n\n        return (\n            <div className=\"App\">\n                <div className=\"main\">\n                    <div className=\"navbar\">\n                        <div className=\"logo\"/>\n                    </div>\n                    <div className=\"page-content\">\n                        { ethereum.web3 && optionRequestState === \"SUCCESS\" ?\n                            <Fragment>\n                                <div className=\"container\">\n                                    <Form optionsData={optionsData}\n                                          updateChartData={(value) => this.updateChartData(value)}\n                                          updatePriceData={(timestamp, priceData) => this.updatePriceData(timestamp, priceData)}\n                                          opynConnector={opynConnector}\n                                    />\n                                </div>\n                                <div className=\"container\">\n                                    The chart below assumes you are providing 1 ETH of value to the pool. 0.5 ETH and 0.5 ETH worth of USDC.\n                                    <HighchartsReact highcharts={Highcharts} options={this.chartDataToDisplay()}/>\n                                </div>\n                            </Fragment>\n                            :\n                            <div className=\"container\">\n                                {this.getErrorMessage()}\n                            </div>\n                        }\n                    </div>\n                    <div className=\"footer\">\n                        <a href=\"https://github.com/conspyrosy/hedgehog\">Contribute</a>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.scss';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}