{"version":3,"sources":["../../opyn-connector/index.js","../../opyn-connector/main/connector.js","../../opyn-connector/utils/utils.js","utils/getChartData.js","components/Form.js","components/App.js","serviceWorker.js","index.js","utils/opynUtils.js"],"names":["router","require","module","exports","batchRequest","FACTORY_ABI","EXCHANGE_ABI","OTOKEN_ABI","convertToFloatingPoint","OpynConnector","web3","config","Error","this","option","expiry","Math","floor","Date","now","filters","getDefaultFilters","getOptionsContractAddresses","getOptionsInformation","optionsAddresses","optionsInfo","optionsContracts","filterOptionsContracts","Promise","resolve","reject","eth","Contract","factory","methods","getNumberOfOptionsContracts","call","then","numberOfOptions","calls","Array","parseInt","keys","map","optionKey","ethCall","makeBatchRequest","result","catch","err","pools","constants","floatingPointFields","addressFields","address","methodName","onError","console","log","flat","optionList","optionIndex","length","currentOption","toLowerCase","propertyIndex","currentProperty","currentPropertyValue","includes","push","contracts","filtered","filterIndex","currentFilter","filter","oTokenAddress","paymentTokenAddress","oTokensToBuy","exchange","premiumToPay","isCall","amountOptionsToBuy","oTokensNeeded","round","strikePrice","pow","decimals","scientificNumber","value","exponent","getCallStrikePrice","getPutStrikePrice","points","calculateImpermanentLoss","priceFactor","abs","sqrt","addOptionStrikePriceToPoints","pointsOfInterest","currentPrice","x","absolutePrices","point","absolutePrice","indexToInsertAt","findIndex","number","splice","impermanentLoss","identifier","calculateOptionReturn","forEach","callReturn","putReturn","getPricePoints","maxFactor","price","callPrice","putPrice","relevantPoints","addAbsolutePrice","reverse","calculateOptionReturns","dateFormat","supportedPairs","getOptionsForPair","generateOptionKey","Form","state","currentPair","optionsExpiry","Object","props","optionsData","token0","token1","callIndex","putIndex","callsNeeded","putsNeeded","pairIndex","recalculateChartData","fetchUniswapPoolPrice","prevProps","prevState","opynConnector","prevPropsNoConnector","propsNoConnector","JSON","stringify","token","Token","ChainId","MAINNET","Fetcher","fetchPairData","WETH","chainId","pair","route","Route","parseFloat","midPrice","toFixed","toString","setState","event","target","isPut","attributeName","updateChartData","putOption","getPutOptions","callOption","onPriceUpdate","callStrikePrice","undefined","putStrikePrice","chartData","chart","type","title","text","series","name","data","xAxis","categories","toPrecision","priceChangePercentage","getPriceChangeLabelForAxis","yAxis","timestamp","all","getPriceOrResolveToZero","getPriceOfPurchase","getOptionsPricesAsync","callCost","putCost","optionsRequired","getChartAndPurchaseData","getCallOptions","updatePriceData","callOptions","underlying","putOptions","className","htmlFor","id","index","token0_name","token1_name","onClick","setPriceFactor","onChange","evt","setOptionsExpiry","key","setOptionIndex","disabled","put","Component","Web3","App","ethereum","priceData","calculateOptionCost","cost","amountOfOptions","chartDataToDisplay","calculateOptionsCost","infuraweb3","providers","HttpProvider","optionRequestState","init","getRestructuredOptions","highcharts","Highcharts","options","getErrorMessage","href","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error","message","merge","ethAndWeth","strike","restructured","optionsList"],"mappings":"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","file":"static/js/main.5f171ae8.chunk.js","sourcesContent":["const router = require(\"./main/connector\");\n\nmodule.exports = router;","const batchRequest = require('web3-batch-request');\n\nconst FACTORY_ABI = require('../abi/factory.json');\nconst EXCHANGE_ABI = require('../abi/exchange.json');\nconst OTOKEN_ABI = require('../abi/otoken.json');\nconst { convertToFloatingPoint } = require('../utils/utils');\n\nclass OpynConnector {\n    constructor({\n        web3,\n        config\n    }) {\n        if (!web3) {\n            throw new Error(\"You must pass in a web3 instance\");\n        }\n\n        if (!config) {\n            this.config = require('../constants/mainnet.json');\n        } else {\n            this.config = config;\n        }\n\n        this.web3 = web3;\n    }\n\n    getDefaultFilters() {\n        const filterExpired = option => option.expiry > Math.floor(Date.now() / 1000);\n        return [filterExpired];\n    }\n\n    /**\n     * Fetch all options from the factory and filter using the filters passed (if any - by default filters expired out)\n     *\n     * @param filters array of filters to run options through. by default filters any expired options.\n     * @returns array of options, filtered if any specified.\n     */\n    async init({ filters } = { filters: this.getDefaultFilters() }) {\n        await this.getOptionsContractAddresses();\n        let optionsInfo = await this.getOptionsInformation(this.optionsAddresses);\n        this.optionsContracts = this.filterOptionsContracts(optionsInfo, filters);\n        return this.optionsContracts;\n    }\n\n    getOptionsContractAddresses() {\n        return new Promise((resolve, reject) => {\n            new this.web3.eth.Contract(FACTORY_ABI, this.config.factory).methods.getNumberOfOptionsContracts().call().then(\n                numberOfOptions => {\n                    let calls = [...Array(parseInt(numberOfOptions)).keys()].map(optionKey => ({\n                        ethCall: new this.web3.eth.Contract(FACTORY_ABI, this.config.factory).methods.optionsContracts(optionKey).call\n                    }));\n\n                    batchRequest.makeBatchRequest(this.web3, calls).then(\n                        result => {\n                            this.optionsAddresses = result;\n                            resolve(result);\n                        }\n                    ).catch(err => {\n                        reject(\"Failed during fetch of pool addresses \" + err);\n                    });\n                }\n            ).catch(\n                err => reject(\"Failed to fetch option contracts count \" + err)\n            )\n        });\n    }\n\n    getOptionsInformation(pools, { filters } = { filters: []}) {\n        return new Promise((resolve, reject) => {\n\n            let constants = [\n                \"name\", \"isExerciseWindow\", \"totalSupply\", \"decimals\", \"liquidationFactor\", \"optionsExchange\",\n                \"underlying\", \"COMPOUND_ORACLE\", \"liquidationIncentive\", \"owner\", \"isOwner\", \"hasExpired\",\n                \"symbol\", \"transactionFee\", \"strike\", \"underlyingExp\", \"collateralExp\", \"oTokenExchangeRate\",\n                \"minCollateralizationRatio\", \"strikePrice\", \"collateral\", \"expiry\"\n            ];\n\n            //fields in this list will be converted to floating points when returned\n            let floatingPointFields = [\"liquidationFactor\", \"liquidationIncentive\", \"transactionFee\",\n                                       \"oTokenExchangeRate\", \"minCollateralizationRatio\", \"strikePrice\"];\n\n            //fields in this list will be lowercased to prevent any case-sensitivity issues when searching\n            let addressFields = [\"optionsExchange\", \"underlying\", \"COMPOUND_ORACLE\", \"owner\", \"strike\", \"collateral\"];\n\n            let calls = pools.map(address =>\n                    constants.map(methodName => ({\n                        ethCall: new this.web3.eth.Contract(OTOKEN_ABI, address).methods[methodName]().call,\n                        onError: err => console.log(\"Error on: \" + address + \" \" + methodName)\n                    })\n                )\n            ).flat();\n\n            batchRequest.makeBatchRequest(this.web3, calls).then(\n                result => {\n                    let optionList = [];\n\n                    //theres probably a more elegant way to do this with destructuring...\n                    for(let optionIndex = 0; optionIndex < pools.length; optionIndex++) {\n                        let currentOption = {};\n                        currentOption.address = pools[optionIndex].toLowerCase();\n                        for(let propertyIndex = 0; propertyIndex < constants.length; propertyIndex++) {\n                            let currentProperty = constants[propertyIndex];\n                            let currentPropertyValue = result[(optionIndex * constants.length) + propertyIndex];\n\n                            if(floatingPointFields.includes(currentProperty)) {\n                                currentOption[currentProperty] = convertToFloatingPoint(currentPropertyValue);\n                            } else if(addressFields.includes(currentProperty)) {\n                                currentOption[currentProperty] = currentPropertyValue.toLowerCase();\n                            } else {\n                                currentOption[currentProperty] = currentPropertyValue;\n                            }\n                        }\n\n                        optionList.push(currentOption);\n                    }\n\n                    this.optionsContracts = optionList;\n                    resolve(optionList);\n                }\n            ).catch(err => {\n                reject(err);\n            });\n        });\n    }\n\n    filterOptionsContracts(contracts, filters = []) {\n        let filtered = contracts;\n\n        if(filters.length > 0) {\n            for(let filterIndex = 0; filterIndex < filters.length; filterIndex++) {\n                const currentFilter = filters[filterIndex];\n                filtered = contracts.filter(option => currentFilter(option));\n            }\n        }\n\n        return filtered;\n    }\n\n    premiumToPay(oTokenAddress, paymentTokenAddress, oTokensToBuy) {\n        return new this.web3.eth.Contract(EXCHANGE_ABI, this.config.exchange).methods.premiumToPay(oTokenAddress, paymentTokenAddress, oTokensToBuy).call();\n    }\n\n    getPriceOfPurchase(option, isCall, amountOptionsToBuy, paymentTokenAddress = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\") {\n        let oTokensNeeded;\n\n        if(isCall) {\n            //todo: shouldnt need rounding - floating point precision issue. fix this!!!\n            oTokensNeeded = Math.round(amountOptionsToBuy / option.strikePrice);\n        } else {\n            //todo: shouldnt need rounding - floating point precision issue. fix this!!!\n            oTokensNeeded = Math.round(amountOptionsToBuy * Math.pow(10, option.decimals));\n        }\n\n        return this.premiumToPay(option.address, paymentTokenAddress, oTokensNeeded);\n    }\n}\n\nmodule.exports = OpynConnector;","module.exports = {\n    /**\n     * Converts a scientific number format to a floating point\n     * floating point number = value * 10 ** exponent\n     *\n     * @param scientificNumber { value, exponent } to fit equation above\n     */\n    convertToFloatingPoint: (scientificNumber) => {\n        return scientificNumber.value * Math.pow(10, scientificNumber.exponent)\n    }\n}","const { getCallStrikePrice, getPutStrikePrice } = require('./opynUtils');\n\n//these reflect a factor of the price e.g. 2 means 2x or 0.5x\nconst points = [1.25, 1.5, 1.75, 2, 3, 4, 5];\n\nconst calculateImpermanentLoss = priceFactor => Math.abs(2 * (Math.sqrt(priceFactor) / (priceFactor + 1)) - 1);\n\nconst addOptionStrikePriceToPoints = (pointsOfInterest, isCall, currentPrice, strikePrice) => {\n    const absolutePrices = pointsOfInterest.map(point => point.absolutePrice);\n\n    const isLargerThan = (x) => (number) => number > x;\n\n    //we need to put in the put price and call price into the price points at the right index\n    if (!absolutePrices.includes(strikePrice)) {\n        const indexToInsertAt = absolutePrices.findIndex(isLargerThan(strikePrice));\n        const priceFactor = strikePrice / currentPrice;\n        pointsOfInterest.splice(indexToInsertAt, 0, {\n            priceFactor,\n            absolutePrice: strikePrice,\n            impermanentLoss: calculateImpermanentLoss(priceFactor),\n            identifier: isCall ? 'callStrike' : 'putStrike'\n        });\n    }\n}\n\nconst calculateOptionReturn = (pointsOfInterest, isCall) => {\n    const identifier = isCall ? 'callStrike' : 'putStrike';\n    const strikePrice = pointsOfInterest.filter(point => point.identifier === identifier).map(point => point.absolutePrice);\n\n    //if a strike for the option exists calculate the returns for that option\n    if(strikePrice.length > 0) {\n        //populate all points with options return values\n        pointsOfInterest.forEach(\n            point => {\n                if(isCall) {\n                    point.callReturn = point.absolutePrice <= strikePrice[0] ? 0 : point.absolutePrice - strikePrice[0];\n                } else {\n                    point.putReturn = point.absolutePrice >= strikePrice[0] ? 0 : strikePrice[0] - point.absolutePrice;\n                }\n            }\n        )\n    }\n}\n\nconst calculateOptionReturns = (pointsOfInterest) => {\n    calculateOptionReturn(pointsOfInterest, true);\n    calculateOptionReturn(pointsOfInterest, false);\n}\n\n/**\n * This gets the points on the x-axis which we want to plot. It uses the \"points\" array to find price\n * points in the range we care about\n *\n * @param maxFactor max price factor we care about e.g. 2 means 0.5x - , 3 means 0.33x - 3x etc\n * @param price current price of asset\n * @param callPrice strike price of call - this point is plotted\n * @param putPrice strike price of put - this point is plotted\n * @returns a list of price points, with each having a price, price factor (ratio to current price) and impermanentloss\n */\nconst getPricePoints = (maxFactor, price, callPrice, putPrice) => {\n    const relevantPoints = points.filter(value => value <= maxFactor).map(value => ({\n        priceFactor: value,\n        impermanentLoss: calculateImpermanentLoss(value)\n    }));\n\n    const inversePoints = [...relevantPoints].reverse().map(\n        value => ({\n            ...value,\n            priceFactor: 1 / value.priceFactor\n        })\n    )\n\n    const addAbsolutePrice = pointsOfInterest => pointsOfInterest.map(point => ({\n            ...point,\n            absolutePrice: point.priceFactor * price\n        })\n    );\n\n    let pointsOfInterest = [\n        addAbsolutePrice(inversePoints),\n        { priceFactor: 1, impermanentLoss: 0, absolutePrice: price },\n        addAbsolutePrice(relevantPoints)\n    ].flat();\n\n    if (callPrice) {\n        addOptionStrikePriceToPoints(pointsOfInterest, true, price, callPrice);\n    }\n\n    if (putPrice) {\n        addOptionStrikePriceToPoints(pointsOfInterest, false, price, putPrice);\n    }\n\n    //we avoid doing this until all points are generated otherwise we will have missing data for some points\n    calculateOptionReturns(pointsOfInterest);\n\n    return pointsOfInterest;\n};\n\nconst getPriceChangeLabelForAxis = (currentPrice, point) => {\n    const priceChangePercentage = ((point.priceFactor - 1) * 100);\n    if(priceChangePercentage === 0) {\n        return '';\n    } else if(priceChangePercentage > 0) {\n        return '<br />(+' + priceChangePercentage.toFixed(1).toString() + '%)';\n    } else {\n        return '<br />(' + priceChangePercentage.toFixed(1).toString()  + '%)';\n    }\n}\n\n/**\n * Generates the chart data from the relevant inputs\n *\n * @param priceFactor the factor of change in price we care about. e.g. 2 means 0.5x - 2x\n * @param currentPrice the current price of the pair\n * @param callStrikePrice the strike price of the call we are hedging with (-1 if no call used)\n * @param putStrikePrice the strike price of the put we are hedging with (-1 if no put used)\n * @param callCost the cost of a single call option\n * @param putCost the cost of a single put option\n * @param opynConnector an instance of OpynConnector so we can fetch prices of options\n */\nconst getChartAndPurchaseData = ({\n      priceFactor,\n      currentPrice,\n      callOption,\n      putOption,\n      onPriceUpdate,\n      opynConnector\n}) => {\n    const callStrikePrice = !callOption ? undefined : getCallStrikePrice(callOption);\n    const putStrikePrice = !putOption ? undefined : getPutStrikePrice(putOption);\n\n    const pointsOfInterest = getPricePoints(priceFactor, currentPrice, callStrikePrice, putStrikePrice);\n\n    let putsNeeded = 0;\n    if(pointsOfInterest[0].putReturn > 0) {\n        putsNeeded = pointsOfInterest[0].impermanentLoss * currentPrice / pointsOfInterest[0].putReturn;\n    }\n\n    let callsNeeded = 0;\n    if(pointsOfInterest[pointsOfInterest.length - 1].callReturn > 0) {\n        callsNeeded = pointsOfInterest[pointsOfInterest.length - 1].impermanentLoss * currentPrice / pointsOfInterest[pointsOfInterest.length - 1].callReturn;\n    }\n\n    const chartData = {\n        chart: {\n            type: 'spline'\n        },\n        title: {\n            text: 'Profit/Loss'\n        },\n        series: [\n            {\n                name: 'Impermanent Loss',\n                data: pointsOfInterest.map(point => point.impermanentLoss * currentPrice)\n            },\n            /*\n            {\n                name: 'Net Profit',\n                data: calculatePutReturns().map((val, id) => val + calculateCallReturns()[id] + costOfOptions - (absoluteImpermanentLoss[id] || 0))\n            }\n            */\n        ],\n        xAxis: {\n            categories: pointsOfInterest.map(point => {\n                return point.absolutePrice.toPrecision(5).toString() + getPriceChangeLabelForAxis(currentPrice, point)\n            }),\n            title: {\n                text: \"Price (USDC)\"\n            }\n        },\n        yAxis: {\n            title: {\n                text: \"Profit/Loss (USDC)\"\n            }\n        },\n    };\n\n    const timestamp = Date.now();\n\n    //if undefined, resolve promise to 0 else get price\n    const getOptionsPricesAsync = () => {\n        const getPriceOrResolveToZero = (option, isCall, amountOptionsToBuy) => {\n            if(option) {\n                return opynConnector.getPriceOfPurchase(option, isCall, amountOptionsToBuy);\n            }\n            return new Promise((resolve) => {\n                resolve(0)\n            });\n        }\n\n        return [\n            getPriceOrResolveToZero(callOption, true, 1),\n            getPriceOrResolveToZero(putOption, false, 1)\n        ];\n    }\n\n    //publish result to state async\n    Promise.all(getOptionsPricesAsync()).then(\n        ([callCost, putCost]) => {\n            const priceData = {\n                timestamp,\n                callCost,\n                putCost,\n                callsNeeded,\n                putsNeeded,\n            }\n            onPriceUpdate(timestamp, priceData)\n        }\n    )\n\n    if(putStrikePrice) {\n        chartData.series.push({\n            name: 'Put Returns',\n            data: pointsOfInterest.map(point => putsNeeded * point.putReturn)\n        });\n    }\n\n    if(callStrikePrice) {\n        chartData.series.push({\n            name: 'Call Returns',\n            data: pointsOfInterest.map(point => callsNeeded * point.callReturn)\n        });\n    }\n\n    return {\n        chartData,\n        optionsRequired: {\n            callsNeeded,\n            putsNeeded\n        }\n    };\n}\n\nexport {\n    getChartAndPurchaseData\n}","import React, {Component} from 'react';\nimport { ChainId, Token, WETH, Fetcher, Route } from '@uniswap/sdk';\nimport { getChartAndPurchaseData } from '../utils/getChartData';\nconst dateFormat = require('dateformat');\nconst supportedPairs = require('./../constants/supportedPairs.json'); //hardcoded for now...\nconst {\n    getOptionsForPair,\n    generateOptionKey,\n    getCallStrikePrice,\n    getPutStrikePrice\n} = require('../utils/opynUtils');\n\nclass Form extends Component {\n    state = {\n        currentPair: supportedPairs[0],\n        priceFactor: 2,\n        optionsExpiry: Object.keys(this.props.optionsData[generateOptionKey(supportedPairs[0].token0,supportedPairs[0].token1)])[0],\n        callIndex: 0,\n        putIndex: 0,\n        callsNeeded: 0,\n        putsNeeded: 0,\n        currentPrice: 1,\n        pairIndex: 0\n    }\n\n    componentDidMount() {\n        this.recalculateChartData();\n\n        //todo: this should update periodically to keep price fresh\n        this.fetchUniswapPoolPrice();\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        const { opynConnector: a, ...prevPropsNoConnector } = prevProps;\n        const { opynConnector: b, ...propsNoConnector } = this.props;\n\n        if(JSON.stringify(prevPropsNoConnector) !== JSON.stringify(propsNoConnector) || JSON.stringify(prevState) !== JSON.stringify(this.state)) {\n            this.recalculateChartData();\n        }\n    }\n\n    fetchUniswapPoolPrice() {\n        const token = new Token(ChainId.MAINNET, supportedPairs[this.state.pairIndex].token1, 6);\n\n        Fetcher.fetchPairData(token, WETH[token.chainId]).then(\n            pair => {\n                const route = new Route([pair], WETH[token.chainId])\n                const currentPrice = parseFloat(route.midPrice.toFixed(2).toString());\n                this.setState({ currentPrice });\n            }\n        )\n    }\n\n    setPriceFactor(priceFactor) {\n        this.setState({\n            priceFactor\n        });\n    };\n\n    setOptionsExpiry(event) {\n        const optionsExpiry = event.target.value;\n        this.setState({\n            optionsExpiry,\n            putIndex: 0,\n            callIndex: 0\n        });\n    }\n\n    /**\n     * Set index of put or call\n     * @param isPut true to set put index, false for call index\n     */\n    setOptionIndex(event, isPut) {\n        const attributeName = isPut ? \"putIndex\" : \"callIndex\";\n        this.setState({\n            [attributeName]: parseInt(event.target.value),\n        });\n    }\n\n    recalculateChartData() {\n        //settings\n        const { priceFactor, optionsExpiry, putIndex, callIndex, currentPrice } = this.state;\n        const { optionsData, updateChartData, opynConnector } = this.props;\n\n        const putOption = this.getPutOptions()[putIndex];\n        const callOption = this.getCallOptions()[callIndex];\n\n        const {\n            chartData,\n            optionsRequired: {\n                callsNeeded,\n                putsNeeded\n            }\n        } = getChartAndPurchaseData({\n            priceFactor,\n            currentPrice,\n            callOption,\n            putOption,\n            onPriceUpdate: this.props.updatePriceData,\n            opynConnector\n        });\n\n        this.setState({\n            callsNeeded,\n            putsNeeded\n        });\n\n        updateChartData(chartData);\n    }\n\n    getCallOptions() {\n        const { currentPair, optionsExpiry } = this.state;\n        const { optionsData } = this.props;\n        const callOptions = getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)[optionsExpiry];\n        if(callOptions) {\n            return callOptions.filter(option => option.underlying === '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\n        }\n        return [];\n    }\n\n    getPutOptions() {\n        const { currentPair, optionsExpiry } = this.state;\n        const { optionsData } = this.props;\n        const putOptions = getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)[optionsExpiry];\n        if(putOptions) {\n            return putOptions.filter(option => option.underlying !== '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\n        }\n        return [];\n    }\n\n    render() {\n        const { optionsData } = this.props;\n        const { priceFactor, optionsExpiry, callsNeeded, putsNeeded, currentPair } = this.state;\n\n        return (\n            <div className=\"options-form\">\n                <div className=\"label-holder\">\n                    <label htmlFor=\"pool\">Pick a pool:</label>\n                </div>\n\n                <select name=\"pool\" id=\"pool\" className=\"form-control\">\n                    {supportedPairs.map(\n                        (pair, index) => (\n                            <option value={index}>{pair.token0_name + \"-\" + pair.token1_name}</option>\n                        )\n                    )}\n                </select>\n\n                <br/>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"priceFactor\">Price Change to Hedge:</label>\n                </div>\n\n                <div className=\"button-group\">\n                    <button className={priceFactor === 2 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(2)}>2x\n                    </button>\n                    <button className={priceFactor === 3 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(3)}>3x\n                    </button>\n                    <button className={priceFactor === 4 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(4)}>4x\n                    </button>\n                    <button className={priceFactor === 5 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(5)}>5x\n                    </button>\n                </div>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"expiry\">Options Expiry Date:</label>\n                </div>\n\n                <select name=\"expiry\" id=\"expiry\" className=\"form-control\" value={optionsExpiry}\n                        onChange={(evt) => this.setOptionsExpiry(evt)}>\n                    {\n                        Object.keys(getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)).map(\n                            key => (\n                                <option value={key}>{dateFormat(new Date(key * 1000), \"d mmmm yyyy h:MM\")}</option>\n                            )\n                        )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"call\">Call Strike Price:</label>\n                </div>\n\n                <select name=\"call\" id=\"call\" className=\"form-control\" onChange={(evt) => this.setOptionIndex(evt, false)}>\n                    {\n                        this.getCallOptions().length < 1 ?\n                            <option value=\"-1\" disabled=\"disabled\">No calls available</option>\n                        :\n                        this.getCallOptions().map(\n                            (call, index) => <option value={index}>{getCallStrikePrice(call)}</option>\n                        )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"put\">Put Strike Price:</label>\n                </div>\n\n                <select name=\"put\" id=\"put\" className=\"form-control\" onChange={(evt) => this.setOptionIndex(evt, true)}>\n                    {\n                        this.getPutOptions().length < 1 ?\n                            <option value=\"-1\" disabled=\"disabled\">No puts available</option>\n                            :\n                            this.getPutOptions().map(\n                                (put, index) => <option value={index}>{getPutStrikePrice(put)}</option>\n                            )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"call-tokens-amount\">Call options to Buy:</label>\n                </div>\n\n                <input className=\"form-control\" name=\"call-tokens-amount\" value={callsNeeded} disabled/>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"put-tokens-amount\">Put options to Buy:</label>\n                </div>\n\n                <input className=\"form-control\" name=\"put-tokens-amount\" value={putsNeeded} disabled/>\n            </div>\n        )\n    }\n}\n\nexport default Form;","import React, { Component, Fragment } from 'react';\nimport Form from './Form';\nimport Highcharts from 'highcharts';\nimport HighchartsReact from \"highcharts-react-official\";\nimport { getRestructuredOptions } from '../utils/opynUtils';\nconst Web3 = require(\"web3\");\nconst OpynConnector = require('opyn-connector');\n\nclass App extends Component {\n    state = {\n        chartData: {},\n        ethereum: {},\n        optionsData: {},\n        priceData: {\n            timestamp: 0,\n            callCost: 0,\n            putCost: 0,\n            callsNeeded: 0,\n            putsNeeded: 0,\n        }\n    }\n\n    calculateOptionsCost() {\n        const { callCost, putCost, callsNeeded, putsNeeded } = this.state.priceData;\n\n        const calculateOptionCost = (cost, amountOfOptions) => {\n            if(!cost || !amountOfOptions) {\n                return 0;\n            }\n            return (cost / 1000000) * amountOfOptions;\n        }\n\n        return calculateOptionCost(callCost, callsNeeded) + calculateOptionCost(putCost, putsNeeded);\n    }\n\n    chartDataToDisplay() {\n        if(Object.keys(this.state.chartData).length > 0) {\n            let chartDataToDisplay = {...this.state.chartData};\n            chartDataToDisplay.series = [...chartDataToDisplay.series]\n            chartDataToDisplay.series.push({\n                name: 'Options Cost',\n                data: chartDataToDisplay.series[0].data.map(point => this.calculateOptionsCost())\n            });\n            return chartDataToDisplay;\n        }\n        return {};\n    }\n\n    componentDidMount() {\n        //for some reason metamask doesnt like batch requests... using infura\n        const infuraweb3 = new Web3(\n            new Web3.providers.HttpProvider(`https://mainnet.infura.io/v3/3425960a247b4ae9b94e7d0e51c1bef0`)\n        );\n        const opynConnector = new OpynConnector({ web3: infuraweb3 });\n        this.setState({\n            ethereum: {\n                web3: infuraweb3,\n            },\n            chartData: {},\n            opynConnector,\n        });\n        this.setState({ optionRequestState: \"LOADING\" })\n        opynConnector.init().then(\n            result => {\n                const optionsData = getRestructuredOptions(result);\n                this.setState({\n                    optionRequestState: \"SUCCESS\",\n                    optionsData\n                })\n            }\n        ).catch(\n            err => this.setState({ optionRequestState: \"FAILED\" })\n        );\n    }\n\n    //take timestamp in case we get requests back out of order\n    updatePriceData(timestamp, priceData) {\n        if(timestamp > this.state.priceData.timestamp) {\n            this.setState({\n                priceData\n            });\n        }\n    }\n\n    updateChartData(chartData) {\n        this.setState({ chartData })\n    }\n\n    getErrorMessage() {\n        if(!this.state.ethereum.web3) {\n            return \"Failed to get web3 provider\";\n        } else if(this.state.optionRequestState === \"LOADING\") {\n            return \"Loading options... this may take up to 30 seconds\"\n        } else if(this.state.optionRequestState === \"FAILED\") {\n            return \"Failed to fetch option data. Refresh to try again\"\n        }\n    }\n\n    render() {\n        const { optionsData, ethereum, optionRequestState, opynConnector } = this.state;\n\n        return (\n            <div className=\"App\">\n                <div className=\"main\">\n                    <div className=\"navbar\">\n                        <div className=\"logo\"/>\n                    </div>\n                    <div className=\"page-content\">\n                        { ethereum.web3 && optionRequestState === \"SUCCESS\" ?\n                            <Fragment>\n                                <div className=\"container\">\n                                    <Form optionsData={optionsData}\n                                          updateChartData={(value) => this.updateChartData(value)}\n                                          updatePriceData={(timestamp, priceData) => this.updatePriceData(timestamp, priceData)}\n                                          opynConnector={opynConnector}\n                                    />\n                                </div>\n                                <div className=\"container\">\n                                    The chart below assumes you are providing 1 ETH of value to the pool. 0.5 ETH and 0.5 ETH worth of USDC.\n                                    <HighchartsReact highcharts={Highcharts} options={this.chartDataToDisplay()}/>\n                                </div>\n                            </Fragment>\n                            :\n                            <div className=\"container\">\n                                {this.getErrorMessage()}\n                            </div>\n                        }\n                    </div>\n                    <div className=\"footer\">\n                        <a href=\"https://github.com/conspyrosy/hedgehog\">Contribute</a>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.scss';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","const merge = require('deepmerge')\n\nconst ethAndWeth = [\"0x0000000000000000000000000000000000000000\", \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"];\n\nconst generateOptionKey = (strike, underlying) => {\n    strike = strike.toLowerCase();\n    underlying = underlying.toLowerCase();\n\n    if(strike === ethAndWeth[1]) {\n        strike = ethAndWeth[0];\n    }\n\n    if(underlying === ethAndWeth[1]) {\n        underlying = ethAndWeth[1];\n    }\n\n    return strike > underlying ? strike + underlying : underlying + strike;\n}\n\nconst getRestructuredOptions = (data) => {\n    let restructured = {};\n\n    data.forEach(\n        option => {\n            const {strike, underlying, expiry} = option;\n            const optionKey = generateOptionKey(strike, underlying);\n\n            if (restructured[optionKey] === undefined) {\n                restructured[optionKey] = {};\n            }\n\n            if (restructured[optionKey][expiry] === undefined) {\n                restructured[optionKey][expiry] = [];\n            }\n\n            restructured[optionKey][expiry].push(option);\n        }\n    );\n\n    return restructured;\n}\n\nconst getOptionsForPair = (optionsList, strike, underlying) => {\n    strike = strike.toLowerCase();\n    underlying = underlying.toLowerCase();\n\n    //since for eth pairs we also need to check for weth, we form a list of keys we need and merge them after\n    const keys = [];\n\n    if(ethAndWeth.includes(strike)) {\n        keys.push(generateOptionKey(underlying, ethAndWeth[0]));\n        keys.push(generateOptionKey(underlying, ethAndWeth[1]));\n    } else if(ethAndWeth.includes(underlying)) {\n        keys.push(generateOptionKey(strike, ethAndWeth[0]));\n        keys.push(generateOptionKey(strike, ethAndWeth[1]));\n    } else {\n        keys.push(generateOptionKey(strike, underlying));\n    }\n\n    //return merged if 2 values, else merge with empty i.e. return first\n    return merge(optionsList[keys[0]], (optionsList[keys[1]] || {}));\n}\n\nconst getCallStrikePrice = call => {\n    const strikePrice = 1 / (call.strikePrice * Math.pow(10, call.decimals));\n    //todo math.round is a hack due to floating point precision... fix\n    return Math.round(strikePrice);\n}\n\nconst getPutStrikePrice = put => {\n    const strikePrice = put.strikePrice * Math.pow(10, put.decimals);\n    //todo math.round is a hack due to floating point precision... fix\n    return Math.round(strikePrice);\n}\n\nexport {\n    generateOptionKey,\n    getOptionsForPair,\n    getRestructuredOptions,\n    getCallStrikePrice,\n    getPutStrikePrice\n}"],"sourceRoot":""}