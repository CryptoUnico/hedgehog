{"version":3,"sources":["utils/opynUtils.js","utils/getChartData.js","../../opyn-connector/index.js","../../opyn-connector/main/connector.js","../../opyn-connector/utils/utils.js","components/Form.js","components/App.js","serviceWorker.js","index.js"],"names":["merge","require","ethAndWeth","generateOptionKey","strike","underlying","toLowerCase","module","exports","getOptionsForPair","optionsList","keys","includes","push","getRestructuredOptions","data","restructured","forEach","option","expiry","optionKey","undefined","getCallStrikePrice","call","strikePrice","Math","pow","decimals","round","getPutStrikePrice","put","points","calculateImpermanentLoss","priceFactor","abs","sqrt","addOptionStrikePriceToPoints","pointsOfInterest","isCall","currentPrice","x","absolutePrices","map","point","absolutePrice","indexToInsertAt","findIndex","number","splice","impermanentLoss","identifier","calculateOptionReturn","filter","length","callReturn","putReturn","getPricePoints","maxFactor","price","callPrice","putPrice","relevantPoints","value","addAbsolutePrice","reverse","flat","calculateOptionReturns","getChartAndPurchaseData","callOption","putOption","onPriceUpdate","opynConnector","callStrikePrice","putStrikePrice","putsNeeded","callsNeeded","chartData","chart","type","title","text","series","name","xAxis","categories","toPrecision","toString","priceChangePercentage","toFixed","getPriceChangeLabelForAxis","yAxis","timestamp","Date","now","Promise","all","getPriceOrResolveToZero","amountOptionsToBuy","getPriceOfPurchase","resolve","getOptionsPricesAsync","then","callCost","putCost","optionsRequired","router","batchRequest","FACTORY_ABI","EXCHANGE_ABI","OTOKEN_ABI","convertToFloatingPoint","OpynConnector","web3","config","Error","this","floor","filters","getDefaultFilters","getOptionsContractAddresses","getOptionsInformation","optionsAddresses","optionsInfo","optionsContracts","filterOptionsContracts","reject","eth","Contract","factory","methods","getNumberOfOptionsContracts","numberOfOptions","calls","Array","parseInt","ethCall","makeBatchRequest","result","catch","err","pools","constants","floatingPointFields","addressFields","address","methodName","onError","console","log","optionList","optionIndex","currentOption","propertyIndex","currentProperty","currentPropertyValue","contracts","filtered","filterIndex","currentFilter","oTokenAddress","paymentTokenAddress","oTokensToBuy","exchange","premiumToPay","oTokensNeeded","scientificNumber","exponent","dateFormat","ChainId","Token","WETH","Fetcher","Route","supportedPairs","Form","state","currentPair","optionsExpiry","Object","props","optionsData","token0","token1","callIndex","putIndex","pairIndex","recalculateChartData","fetchUniswapPoolPrice","prevProps","prevState","prevPropsNoConnector","propsNoConnector","JSON","stringify","token","MAINNET","fetchPairData","chainId","pair","route","parseFloat","midPrice","setState","event","target","isPut","attributeName","updateChartData","getPutOptions","getCallOptions","updatePriceData","callOptions","putOptions","className","htmlFor","id","index","token0_name","token1_name","onClick","setPriceFactor","onChange","evt","setOptionsExpiry","key","setOptionIndex","disabled","Component","Web3","App","ethereum","priceData","calculateOptionCost","cost","amountOfOptions","chartDataToDisplay","calculateOptionsCost","infuraweb3","providers","HttpProvider","optionRequestState","init","highcharts","Highcharts","options","getErrorMessage","href","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.1107af98.chunk.js","sourcesContent":["const merge = require('deepmerge')\n\nconst ethAndWeth = [\"0x0000000000000000000000000000000000000000\", \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"];\n\nconst generateOptionKey = (strike, underlying) => {\n    strike = strike.toLowerCase();\n    underlying = underlying.toLowerCase();\n\n    if(strike === ethAndWeth[1]) {\n        strike = ethAndWeth[0];\n    }\n\n    if(underlying === ethAndWeth[1]) {\n        underlying = ethAndWeth[1];\n    }\n\n    return strike > underlying ? strike + underlying : underlying + strike;\n}\n\nconst getRestructuredOptions = (data) => {\n    let restructured = {};\n\n    data.forEach(\n        option => {\n            const {strike, underlying, expiry} = option;\n            const optionKey = generateOptionKey(strike, underlying);\n\n            if (restructured[optionKey] === undefined) {\n                restructured[optionKey] = {};\n            }\n\n            if (restructured[optionKey][expiry] === undefined) {\n                restructured[optionKey][expiry] = [];\n            }\n\n            restructured[optionKey][expiry].push(option);\n        }\n    );\n\n    return restructured;\n}\n\nconst getOptionsForPair = (optionsList, strike, underlying) => {\n    strike = strike.toLowerCase();\n    underlying = underlying.toLowerCase();\n\n    //since for eth pairs we also need to check for weth, we form a list of keys we need and merge them after\n    const keys = [];\n\n    if(ethAndWeth.includes(strike)) {\n        keys.push(generateOptionKey(underlying, ethAndWeth[0]));\n        keys.push(generateOptionKey(underlying, ethAndWeth[1]));\n    } else if(ethAndWeth.includes(underlying)) {\n        keys.push(generateOptionKey(strike, ethAndWeth[0]));\n        keys.push(generateOptionKey(strike, ethAndWeth[1]));\n    } else {\n        keys.push(generateOptionKey(strike, underlying));\n    }\n\n    //return merged if 2 values, else merge with empty i.e. return first\n    return merge(optionsList[keys[0]], (optionsList[keys[1]] || {}));\n}\n\nconst getCallStrikePrice = call => {\n    const strikePrice = 1 / (call.strikePrice * Math.pow(10, call.decimals));\n    //todo math.round is a hack due to floating point precision... fix\n    return Math.round(strikePrice);\n}\n\nconst getPutStrikePrice = put => {\n    const strikePrice = put.strikePrice * Math.pow(10, put.decimals);\n    //todo math.round is a hack due to floating point precision... fix\n    return Math.round(strikePrice);\n}\n\nmodule.exports = {\n    generateOptionKey,\n    getOptionsForPair,\n    getRestructuredOptions,\n    getCallStrikePrice,\n    getPutStrikePrice\n}","const { getCallStrikePrice, getPutStrikePrice } = require('./opynUtils');\n\n//these reflect a factor of the price e.g. 2 means 2x or 0.5x\nconst points = [1.25, 1.5, 1.75, 2, 3, 4, 5];\n\nconst calculateImpermanentLoss = priceFactor => Math.abs(2 * (Math.sqrt(priceFactor) / (priceFactor + 1)) - 1);\n\nconst addOptionStrikePriceToPoints = (pointsOfInterest, isCall, currentPrice, strikePrice) => {\n    const absolutePrices = pointsOfInterest.map(point => point.absolutePrice);\n\n    const isLargerThan = (x) => (number) => number > x;\n\n    //we need to put in the put price and call price into the price points at the right index\n    if (!absolutePrices.includes(strikePrice)) {\n        const indexToInsertAt = absolutePrices.findIndex(isLargerThan(strikePrice));\n        const priceFactor = strikePrice / currentPrice;\n        pointsOfInterest.splice(indexToInsertAt, 0, {\n            priceFactor,\n            absolutePrice: strikePrice,\n            impermanentLoss: calculateImpermanentLoss(priceFactor),\n            identifier: isCall ? 'callStrike' : 'putStrike'\n        });\n    }\n}\n\nconst calculateOptionReturn = (pointsOfInterest, isCall) => {\n    const identifier = isCall ? 'callStrike' : 'putStrike';\n    const strikePrice = pointsOfInterest.filter(point => point.identifier === identifier).map(point => point.absolutePrice);\n\n    //if a strike for the option exists calculate the returns for that option\n    if(strikePrice.length > 0) {\n        //populate all points with options return values\n        pointsOfInterest.forEach(\n            point => {\n                if(isCall) {\n                    point.callReturn = point.absolutePrice <= strikePrice[0] ? 0 : point.absolutePrice - strikePrice[0];\n                } else {\n                    point.putReturn = point.absolutePrice >= strikePrice[0] ? 0 : strikePrice[0] - point.absolutePrice;\n                }\n            }\n        )\n    }\n}\n\nconst calculateOptionReturns = (pointsOfInterest) => {\n    calculateOptionReturn(pointsOfInterest, true);\n    calculateOptionReturn(pointsOfInterest, false);\n}\n\n/**\n * This gets the points on the x-axis which we want to plot. It uses the \"points\" array to find price\n * points in the range we care about\n *\n * @param maxFactor max price factor we care about e.g. 2 means 0.5x - , 3 means 0.33x - 3x etc\n * @param price current price of asset\n * @param callPrice strike price of call - this point is plotted\n * @param putPrice strike price of put - this point is plotted\n * @returns a list of price points, with each having a price, price factor (ratio to current price) and impermanentloss\n */\nconst getPricePoints = (maxFactor, price, callPrice, putPrice) => {\n    const relevantPoints = points.filter(value => value <= maxFactor).map(value => ({\n        priceFactor: value,\n        impermanentLoss: calculateImpermanentLoss(value)\n    }));\n\n    const inversePoints = [...relevantPoints].reverse().map(\n        value => ({\n            ...value,\n            priceFactor: 1 / value.priceFactor\n        })\n    )\n\n    const addAbsolutePrice = pointsOfInterest => pointsOfInterest.map(point => ({\n            ...point,\n            absolutePrice: point.priceFactor * price\n        })\n    );\n\n    let pointsOfInterest = [\n        addAbsolutePrice(inversePoints),\n        { priceFactor: 1, impermanentLoss: 0, absolutePrice: price },\n        addAbsolutePrice(relevantPoints)\n    ].flat();\n\n    if (callPrice) {\n        addOptionStrikePriceToPoints(pointsOfInterest, true, price, callPrice);\n    }\n\n    if (putPrice) {\n        addOptionStrikePriceToPoints(pointsOfInterest, false, price, putPrice);\n    }\n\n    //we avoid doing this until all points are generated otherwise we will have missing data for some points\n    calculateOptionReturns(pointsOfInterest);\n\n    return pointsOfInterest;\n};\n\nconst getPriceChangeLabelForAxis = (currentPrice, point) => {\n    const priceChangePercentage = ((point.priceFactor - 1) * 100);\n    if(priceChangePercentage === 0) {\n        return '';\n    } else if(priceChangePercentage > 0) {\n        return '<br />(+' + priceChangePercentage.toFixed(1).toString() + '%)';\n    } else {\n        return '<br />(' + priceChangePercentage.toFixed(1).toString()  + '%)';\n    }\n}\n\nmodule.exports = {\n    /**\n     * Generates the chart data from the relevant inputs\n     *\n     * @param priceFactor the factor of change in price we care about. e.g. 2 means 0.5x - 2x\n     * @param currentPrice the current price of the pair\n     * @param callStrikePrice the strike price of the call we are hedging with (-1 if no call used)\n     * @param putStrikePrice the strike price of the put we are hedging with (-1 if no put used)\n     * @param callCost the cost of a single call option\n     * @param putCost the cost of a single put option\n     * @param opynConnector an instance of OpynConnector so we can fetch prices of options\n     */\n    getChartAndPurchaseData: ({\n          priceFactor,\n          currentPrice,\n          callOption,\n          putOption,\n          onPriceUpdate,\n          opynConnector\n    }) => {\n        const callStrikePrice = !callOption ? undefined : getCallStrikePrice(callOption);\n        const putStrikePrice = !putOption ? undefined : getPutStrikePrice(putOption);\n\n        const pointsOfInterest = getPricePoints(priceFactor, currentPrice, callStrikePrice, putStrikePrice);\n\n        let putsNeeded = 0;\n        if(pointsOfInterest[0].putReturn > 0) {\n            putsNeeded = pointsOfInterest[0].impermanentLoss * currentPrice / pointsOfInterest[0].putReturn;\n        }\n\n        let callsNeeded = 0;\n        if(pointsOfInterest[pointsOfInterest.length - 1].callReturn > 0) {\n            callsNeeded = pointsOfInterest[pointsOfInterest.length - 1].impermanentLoss * currentPrice / pointsOfInterest[pointsOfInterest.length - 1].callReturn;\n        }\n\n        const chartData = {\n            chart: {\n                type: 'spline'\n            },\n            title: {\n                text: 'Profit/Loss'\n            },\n            series: [\n                {\n                    name: 'Impermanent Loss',\n                    data: pointsOfInterest.map(point => point.impermanentLoss * currentPrice)\n                },\n                /*\n                {\n                    name: 'Net Profit',\n                    data: calculatePutReturns().map((val, id) => val + calculateCallReturns()[id] + costOfOptions - (absoluteImpermanentLoss[id] || 0))\n                }\n                */\n            ],\n            xAxis: {\n                categories: pointsOfInterest.map(point => {\n                    return point.absolutePrice.toPrecision(5).toString() + getPriceChangeLabelForAxis(currentPrice, point)\n                }),\n                title: {\n                    text: \"Price (USDC)\"\n                }\n            },\n            yAxis: {\n                title: {\n                    text: \"Profit/Loss (USDC)\"\n                }\n            },\n        };\n\n        const timestamp = Date.now();\n\n        //if undefined, resolve promise to 0 else get price\n        const getOptionsPricesAsync = () => {\n            const getPriceOrResolveToZero = (option, isCall, amountOptionsToBuy) => {\n                if(option) {\n                    return opynConnector.getPriceOfPurchase(option, isCall, amountOptionsToBuy);\n                }\n                return new Promise((resolve) => {\n                    resolve(0)\n                });\n            }\n\n            return [\n                getPriceOrResolveToZero(callOption, true, 1),\n                getPriceOrResolveToZero(putOption, false, 1)\n            ];\n        }\n\n        //publish result to state async\n        Promise.all(getOptionsPricesAsync()).then(\n            ([callCost, putCost]) => {\n                const priceData = {\n                    timestamp,\n                    callCost,\n                    putCost,\n                    callsNeeded,\n                    putsNeeded,\n                }\n                onPriceUpdate(timestamp, priceData)\n            }\n        )\n\n        if(putStrikePrice) {\n            chartData.series.push({\n                name: 'Put Returns',\n                data: pointsOfInterest.map(point => putsNeeded * point.putReturn)\n            });\n        }\n\n        if(callStrikePrice) {\n            chartData.series.push({\n                name: 'Call Returns',\n                data: pointsOfInterest.map(point => callsNeeded * point.callReturn)\n            });\n        }\n\n        return {\n            chartData,\n            optionsRequired: {\n                callsNeeded,\n                putsNeeded\n            }\n        };\n    }\n}","const router = require(\"./main/connector\");\n\nmodule.exports = router;","const batchRequest = require('web3-batch-request');\n\nconst FACTORY_ABI = require('../abi/factory.json');\nconst EXCHANGE_ABI = require('../abi/exchange.json');\nconst OTOKEN_ABI = require('../abi/otoken.json');\nconst { convertToFloatingPoint } = require('../utils/utils');\n\nclass OpynConnector {\n    constructor({\n        web3,\n        config\n    }) {\n        if (!web3) {\n            throw new Error(\"You must pass in a web3 instance\");\n        }\n\n        if (!config) {\n            this.config = require('../constants/mainnet.json');\n        } else {\n            this.config = config;\n        }\n\n        this.web3 = web3;\n    }\n\n    getDefaultFilters() {\n        const filterExpired = option => option.expiry > Math.floor(Date.now() / 1000);\n        return [filterExpired];\n    }\n\n    /**\n     * Fetch all options from the factory and filter using the filters passed (if any - by default filters expired out)\n     *\n     * @param filters array of filters to run options through. by default filters any expired options.\n     * @returns array of options, filtered if any specified.\n     */\n    async init({ filters } = { filters: this.getDefaultFilters() }) {\n        await this.getOptionsContractAddresses();\n        let optionsInfo = await this.getOptionsInformation(this.optionsAddresses);\n        this.optionsContracts = this.filterOptionsContracts(optionsInfo, filters);\n        return this.optionsContracts;\n    }\n\n    getOptionsContractAddresses() {\n        return new Promise((resolve, reject) => {\n            new this.web3.eth.Contract(FACTORY_ABI, this.config.factory).methods.getNumberOfOptionsContracts().call().then(\n                numberOfOptions => {\n                    let calls = [...Array(parseInt(numberOfOptions)).keys()].map(optionKey => ({\n                        ethCall: new this.web3.eth.Contract(FACTORY_ABI, this.config.factory).methods.optionsContracts(optionKey).call\n                    }));\n\n                    batchRequest.makeBatchRequest(this.web3, calls).then(\n                        result => {\n                            this.optionsAddresses = result;\n                            resolve(result);\n                        }\n                    ).catch(err => {\n                        reject(\"Failed during fetch of pool addresses \" + err);\n                    });\n                }\n            ).catch(\n                err => reject(\"Failed to fetch option contracts count \" + err)\n            )\n        });\n    }\n\n    getOptionsInformation(pools, { filters } = { filters: []}) {\n        return new Promise((resolve, reject) => {\n\n            let constants = [\n                \"name\", \"isExerciseWindow\", \"totalSupply\", \"decimals\", \"liquidationFactor\", \"optionsExchange\",\n                \"underlying\", \"COMPOUND_ORACLE\", \"liquidationIncentive\", \"owner\", \"isOwner\", \"hasExpired\",\n                \"symbol\", \"transactionFee\", \"strike\", \"underlyingExp\", \"collateralExp\", \"oTokenExchangeRate\",\n                \"minCollateralizationRatio\", \"strikePrice\", \"collateral\", \"expiry\"\n            ];\n\n            //fields in this list will be converted to floating points when returned\n            let floatingPointFields = [\"liquidationFactor\", \"liquidationIncentive\", \"transactionFee\",\n                                       \"oTokenExchangeRate\", \"minCollateralizationRatio\", \"strikePrice\"];\n\n            //fields in this list will be lowercased to prevent any case-sensitivity issues when searching\n            let addressFields = [\"optionsExchange\", \"underlying\", \"COMPOUND_ORACLE\", \"owner\", \"strike\", \"collateral\"];\n\n            let calls = pools.map(address =>\n                    constants.map(methodName => ({\n                        ethCall: new this.web3.eth.Contract(OTOKEN_ABI, address).methods[methodName]().call,\n                        onError: err => console.log(\"Error on: \" + address + \" \" + methodName)\n                    })\n                )\n            ).flat();\n\n            batchRequest.makeBatchRequest(this.web3, calls).then(\n                result => {\n                    let optionList = [];\n\n                    //theres probably a more elegant way to do this with destructuring...\n                    for(let optionIndex = 0; optionIndex < pools.length; optionIndex++) {\n                        let currentOption = {};\n                        currentOption.address = pools[optionIndex].toLowerCase();\n                        for(let propertyIndex = 0; propertyIndex < constants.length; propertyIndex++) {\n                            let currentProperty = constants[propertyIndex];\n                            let currentPropertyValue = result[(optionIndex * constants.length) + propertyIndex];\n\n                            if(floatingPointFields.includes(currentProperty)) {\n                                currentOption[currentProperty] = convertToFloatingPoint(currentPropertyValue);\n                            } else if(addressFields.includes(currentProperty)) {\n                                currentOption[currentProperty] = currentPropertyValue.toLowerCase();\n                            } else {\n                                currentOption[currentProperty] = currentPropertyValue;\n                            }\n                        }\n\n                        optionList.push(currentOption);\n                    }\n\n                    this.optionsContracts = optionList;\n                    resolve(optionList);\n                }\n            ).catch(err => {\n                reject(err);\n            });\n        });\n    }\n\n    filterOptionsContracts(contracts, filters = []) {\n        let filtered = contracts;\n\n        if(filters.length > 0) {\n            for(let filterIndex = 0; filterIndex < filters.length; filterIndex++) {\n                const currentFilter = filters[filterIndex];\n                filtered = contracts.filter(option => currentFilter(option));\n            }\n        }\n\n        return filtered;\n    }\n\n    premiumToPay(oTokenAddress, paymentTokenAddress, oTokensToBuy) {\n        return new this.web3.eth.Contract(EXCHANGE_ABI, this.config.exchange).methods.premiumToPay(oTokenAddress, paymentTokenAddress, oTokensToBuy).call();\n    }\n\n    getPriceOfPurchase(option, isCall, amountOptionsToBuy, paymentTokenAddress = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\") {\n        let oTokensNeeded;\n\n        if(isCall) {\n            //todo: shouldnt need rounding - floating point precision issue. fix this!!!\n            oTokensNeeded = Math.round(amountOptionsToBuy / option.strikePrice);\n        } else {\n            //todo: shouldnt need rounding - floating point precision issue. fix this!!!\n            oTokensNeeded = Math.round(amountOptionsToBuy * Math.pow(10, option.decimals));\n        }\n\n        return this.premiumToPay(option.address, paymentTokenAddress, oTokensNeeded);\n    }\n}\n\nmodule.exports = OpynConnector;","module.exports = {\n    /**\n     * Converts a scientific number format to a floating point\n     * floating point number = value * 10 ** exponent\n     *\n     * @param scientificNumber { value, exponent } to fit equation above\n     */\n    convertToFloatingPoint: (scientificNumber) => {\n        return scientificNumber.value * Math.pow(10, scientificNumber.exponent)\n    }\n}","import React, {Component} from 'react';\nconst dateFormat = require('dateformat');\nconst { ChainId, Token, WETH, Fetcher, Route } = require('@uniswap/sdk');\nconst { getChartAndPurchaseData } = require('./../utils/getChartData');\nconst supportedPairs = require('./../constants/supportedPairs.json'); //hardcoded for now...\nconst {\n    getOptionsForPair,\n    generateOptionKey,\n    getCallStrikePrice,\n    getPutStrikePrice\n} = require('../utils/opynUtils');\n\nclass Form extends Component {\n    state = {\n        currentPair: supportedPairs[0],\n        priceFactor: 2,\n        optionsExpiry: Object.keys(this.props.optionsData[generateOptionKey(supportedPairs[0].token0,supportedPairs[0].token1)])[0],\n        callIndex: 0,\n        putIndex: 0,\n        callsNeeded: 0,\n        putsNeeded: 0,\n        currentPrice: 1,\n        pairIndex: 0\n    }\n\n    componentDidMount() {\n        this.recalculateChartData();\n\n        //todo: this should update periodically to keep price fresh\n        this.fetchUniswapPoolPrice();\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        const { opynConnector: a, ...prevPropsNoConnector } = prevProps;\n        const { opynConnector: b, ...propsNoConnector } = this.props;\n\n        if(JSON.stringify(prevPropsNoConnector) !== JSON.stringify(propsNoConnector) || JSON.stringify(prevState) !== JSON.stringify(this.state)) {\n            this.recalculateChartData();\n        }\n    }\n\n    fetchUniswapPoolPrice() {\n        const token = new Token(ChainId.MAINNET, supportedPairs[this.state.pairIndex].token1, 6);\n\n        Fetcher.fetchPairData(token, WETH[token.chainId]).then(\n            pair => {\n                const route = new Route([pair], WETH[token.chainId])\n                const currentPrice = parseFloat(route.midPrice.toFixed(2).toString());\n                this.setState({ currentPrice });\n            }\n        )\n    }\n\n    setPriceFactor(priceFactor) {\n        this.setState({\n            priceFactor\n        });\n    };\n\n    setOptionsExpiry(event) {\n        const optionsExpiry = event.target.value;\n        this.setState({\n            optionsExpiry,\n            putIndex: 0,\n            callIndex: 0\n        });\n    }\n\n    /**\n     * Set index of put or call\n     * @param isPut true to set put index, false for call index\n     */\n    setOptionIndex(event, isPut) {\n        const attributeName = isPut ? \"putIndex\" : \"callIndex\";\n        this.setState({\n            [attributeName]: parseInt(event.target.value),\n        });\n    }\n\n    recalculateChartData() {\n        //settings\n        const { priceFactor, optionsExpiry, putIndex, callIndex, currentPrice } = this.state;\n        const { optionsData, updateChartData, opynConnector } = this.props;\n\n        const putOption = this.getPutOptions()[putIndex];\n        const callOption = this.getCallOptions()[callIndex];\n\n        const {\n            chartData,\n            optionsRequired: {\n                callsNeeded,\n                putsNeeded\n            }\n        } = getChartAndPurchaseData({\n            priceFactor,\n            currentPrice,\n            callOption,\n            putOption,\n            onPriceUpdate: this.props.updatePriceData,\n            opynConnector\n        });\n\n        this.setState({\n            callsNeeded,\n            putsNeeded\n        });\n\n        updateChartData(chartData);\n    }\n\n    getCallOptions() {\n        const { currentPair, optionsExpiry } = this.state;\n        const { optionsData } = this.props;\n        const callOptions = getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)[optionsExpiry];\n        if(callOptions) {\n            return callOptions.filter(option => option.underlying === '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\n        }\n        return [];\n    }\n\n    getPutOptions() {\n        const { currentPair, optionsExpiry } = this.state;\n        const { optionsData } = this.props;\n        const putOptions = getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)[optionsExpiry];\n        if(putOptions) {\n            return putOptions.filter(option => option.underlying !== '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\n        }\n        return [];\n    }\n\n    render() {\n        const { optionsData } = this.props;\n        const { priceFactor, optionsExpiry, callsNeeded, putsNeeded, currentPair } = this.state;\n\n        return (\n            <div className=\"options-form\">\n                <div className=\"label-holder\">\n                    <label htmlFor=\"pool\">Pick a pool:</label>\n                </div>\n\n                <select name=\"pool\" id=\"pool\" className=\"form-control\">\n                    {supportedPairs.map(\n                        (pair, index) => (\n                            <option value={index}>{pair.token0_name + \"-\" + pair.token1_name}</option>\n                        )\n                    )}\n                </select>\n\n                <br/>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"priceFactor\">Price Change to Hedge:</label>\n                </div>\n\n                <div className=\"button-group\">\n                    <button className={priceFactor === 2 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(2)}>2x\n                    </button>\n                    <button className={priceFactor === 3 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(3)}>3x\n                    </button>\n                    <button className={priceFactor === 4 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(4)}>4x\n                    </button>\n                    <button className={priceFactor === 5 ? \"selected\" : \"\"}\n                            onClick={() => this.setPriceFactor(5)}>5x\n                    </button>\n                </div>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"expiry\">Options Expiry Date:</label>\n                </div>\n\n                <select name=\"expiry\" id=\"expiry\" className=\"form-control\" value={optionsExpiry}\n                        onChange={(evt) => this.setOptionsExpiry(evt)}>\n                    {\n                        Object.keys(getOptionsForPair(optionsData, currentPair.token0, currentPair.token1)).map(\n                            key => (\n                                <option value={key}>{dateFormat(new Date(key * 1000), \"d mmmm yyyy h:MM\")}</option>\n                            )\n                        )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"call\">Call Strike Price:</label>\n                </div>\n\n                <select name=\"call\" id=\"call\" className=\"form-control\" onChange={(evt) => this.setOptionIndex(evt, false)}>\n                    {\n                        this.getCallOptions().length < 1 ?\n                            <option value=\"-1\" disabled=\"disabled\">No calls available</option>\n                        :\n                        this.getCallOptions().map(\n                            (call, index) => <option value={index}>{getCallStrikePrice(call)}</option>\n                        )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"put\">Put Strike Price:</label>\n                </div>\n\n                <select name=\"put\" id=\"put\" className=\"form-control\" onChange={(evt) => this.setOptionIndex(evt, true)}>\n                    {\n                        this.getPutOptions().length < 1 ?\n                            <option value=\"-1\" disabled=\"disabled\">No puts available</option>\n                            :\n                            this.getPutOptions().map(\n                                (put, index) => <option value={index}>{getPutStrikePrice(put)}</option>\n                            )\n                    }\n                </select>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"call-tokens-amount\">Call options to Buy:</label>\n                </div>\n\n                <input className=\"form-control\" name=\"call-tokens-amount\" value={callsNeeded} disabled/>\n\n                <div className=\"label-holder\">\n                    <label htmlFor=\"put-tokens-amount\">Put options to Buy:</label>\n                </div>\n\n                <input className=\"form-control\" name=\"put-tokens-amount\" value={putsNeeded} disabled/>\n            </div>\n        )\n    }\n}\n\nexport default Form;","import React, { Component, Fragment } from 'react';\nimport Form from './Form';\nimport Highcharts from 'highcharts';\nimport HighchartsReact from \"highcharts-react-official\";\nconst Web3 = require(\"web3\");\nconst OpynConnector = require('opyn-connector');\nconst { getRestructuredOptions } = require('../utils/opynUtils');\n\nclass App extends Component {\n    state = {\n        chartData: {},\n        ethereum: {},\n        optionsData: {},\n        priceData: {\n            timestamp: 0,\n            callCost: 0,\n            putCost: 0,\n            callsNeeded: 0,\n            putsNeeded: 0,\n        }\n    }\n\n    calculateOptionsCost() {\n        const { callCost, putCost, callsNeeded, putsNeeded } = this.state.priceData;\n\n        const calculateOptionCost = (cost, amountOfOptions) => {\n            if(!cost || !amountOfOptions) {\n                return 0;\n            }\n            return (cost / 1000000) * amountOfOptions;\n        }\n\n        return calculateOptionCost(callCost, callsNeeded) + calculateOptionCost(putCost, putsNeeded);\n    }\n\n    chartDataToDisplay() {\n        if(Object.keys(this.state.chartData).length > 0) {\n            let chartDataToDisplay = {...this.state.chartData};\n            chartDataToDisplay.series = [...chartDataToDisplay.series]\n            chartDataToDisplay.series.push({\n                name: 'Options Cost',\n                data: chartDataToDisplay.series[0].data.map(point => this.calculateOptionsCost())\n            });\n            return chartDataToDisplay;\n        }\n        return {};\n    }\n\n    componentDidMount() {\n        //for some reason metamask doesnt like batch requests... using infura\n        const infuraweb3 = new Web3(\n            new Web3.providers.HttpProvider(`https://mainnet.infura.io/v3/3425960a247b4ae9b94e7d0e51c1bef0`)\n        );\n        const opynConnector = new OpynConnector({ web3: infuraweb3 });\n        this.setState({\n            ethereum: {\n                web3: infuraweb3,\n            },\n            chartData: {},\n            opynConnector,\n        });\n        this.setState({ optionRequestState: \"LOADING\" })\n        opynConnector.init().then(\n            result => {\n                const optionsData = getRestructuredOptions(result);\n                this.setState({\n                    optionRequestState: \"SUCCESS\",\n                    optionsData\n                })\n            }\n        ).catch(\n            err => this.setState({ optionRequestState: \"FAILED\" })\n        );\n    }\n\n    //take timestamp in case we get requests back out of order\n    updatePriceData(timestamp, priceData) {\n        if(timestamp > this.state.priceData.timestamp) {\n            this.setState({\n                priceData\n            });\n        }\n    }\n\n    updateChartData(chartData) {\n        this.setState({ chartData })\n    }\n\n    getErrorMessage() {\n        if(!this.state.ethereum.web3) {\n            return \"Failed to get web3 provider\";\n        } else if(this.state.optionRequestState === \"LOADING\") {\n            return \"Loading options... this may take up to 30 seconds\"\n        } else if(this.state.optionRequestState === \"FAILED\") {\n            return \"Failed to fetch option data. Refresh to try again\"\n        }\n    }\n\n    render() {\n        const { optionsData, ethereum, optionRequestState, opynConnector } = this.state;\n\n        return (\n            <div className=\"App\">\n                <div className=\"main\">\n                    <div className=\"navbar\">\n                        <div className=\"logo\"/>\n                    </div>\n                    <div className=\"page-content\">\n                        { ethereum.web3 && optionRequestState === \"SUCCESS\" ?\n                            <Fragment>\n                                <div className=\"container\">\n                                    <Form optionsData={optionsData}\n                                          updateChartData={(value) => this.updateChartData(value)}\n                                          updatePriceData={(timestamp, priceData) => this.updatePriceData(timestamp, priceData)}\n                                          opynConnector={opynConnector}\n                                    />\n                                </div>\n                                <div className=\"container\">\n                                    The chart below assumes you are providing 1 ETH of value to the pool. 0.5 ETH and 0.5 ETH worth of USDC.\n                                    <HighchartsReact highcharts={Highcharts} options={this.chartDataToDisplay()}/>\n                                </div>\n                            </Fragment>\n                            :\n                            <div className=\"container\">\n                                {this.getErrorMessage()}\n                            </div>\n                        }\n                    </div>\n                    <div className=\"footer\">\n                        <a href=\"https://github.com/conspyrosy/hedgehog\">Contribute</a>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.scss';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}